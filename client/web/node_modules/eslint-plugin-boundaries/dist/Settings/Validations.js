"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.elementsMatcherSchema = elementsMatcherSchema;
exports.rulesOptionsSchema = rulesOptionsSchema;
exports.isValidElementAssigner = isValidElementAssigner;
exports.validateSettings = validateSettings;
exports.getSettings = getSettings;
const elements_1 = require("@boundaries/elements");
const Common_1 = require("../Support/Common");
const Debug_1 = require("../Support/Debug");
const Helpers_1 = require("./Helpers");
const Settings_1 = require("./Settings");
const Settings_types_1 = require("./Settings.types");
const { TYPES, ALIAS, ELEMENTS, DEPENDENCY_NODES, ADDITIONAL_DEPENDENCY_NODES, VALID_DEPENDENCY_NODE_KINDS, DEFAULT_DEPENDENCY_NODES, VALID_MODES, } = Settings_types_1.SETTINGS;
const DEFAULT_MATCHER_OPTIONS = {
    type: "object",
};
function elementsMatcherSchema(matcherOptions = DEFAULT_MATCHER_OPTIONS) {
    return {
        oneOf: [
            {
                type: "string", // single matcher
            },
            {
                type: "array", // multiple matchers
                items: {
                    oneOf: [
                        {
                            type: "string", // matcher with options
                        },
                        {
                            type: "array",
                            items: [
                                {
                                    type: "string", // matcher
                                },
                                matcherOptions, // options
                            ],
                        },
                    ],
                },
            },
        ],
    };
}
function rulesOptionsSchema(options = {}) {
    const mainKey = (0, Helpers_1.rulesMainKey)(options.rulesMainKey);
    return [
        {
            type: "object",
            properties: {
                message: {
                    type: "string",
                },
                default: {
                    type: "string",
                    enum: ["allow", "disallow"],
                },
                rules: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            [mainKey]: elementsMatcherSchema(),
                            allow: elementsMatcherSchema(options.targetMatcherOptions),
                            disallow: elementsMatcherSchema(options.targetMatcherOptions),
                            importKind: {
                                oneOf: [
                                    {
                                        type: "string",
                                    },
                                    {
                                        type: "array",
                                        items: {
                                            type: "string",
                                        },
                                    },
                                ],
                            },
                            message: {
                                type: "string",
                            },
                        },
                        additionalProperties: false,
                        anyOf: [
                            {
                                required: [mainKey, "allow", "disallow"],
                            },
                            {
                                required: [mainKey, "allow"],
                            },
                            {
                                required: [mainKey, "disallow"],
                            },
                        ],
                    },
                },
            },
            additionalProperties: false,
        },
    ];
}
function isValidElementAssigner(element) {
    if (!element) {
        (0, Debug_1.warnOnce)(`Please provide a valid object to define element types in '${ELEMENTS}' setting`);
        return false;
    }
    if ((0, Helpers_1.isLegacyType)(element)) {
        (0, Debug_1.warnOnce)(`Defining elements as strings in settings is deprecated. Will be automatically converted, but this feature will be removed in next major versions`);
        return true;
    }
    else {
        const isObjectElement = (0, Common_1.isObject)(element);
        if (!isObjectElement) {
            (0, Debug_1.warnOnce)(`Please provide a valid object to define element types in '${ELEMENTS}' setting`);
            return false;
        }
        if (!element.type || !(0, Common_1.isString)(element.type)) {
            (0, Debug_1.warnOnce)(`Please provide type in '${ELEMENTS}' setting`);
            return false;
        }
        if (element.mode &&
            (0, Common_1.isString)(element.mode) &&
            !VALID_MODES.includes(element.mode)) {
            (0, Debug_1.warnOnce)(`Invalid mode property of type ${element.type} in '${ELEMENTS}' setting. Should be one of ${VALID_MODES.join(",")}. Default value "${VALID_MODES[0]}" will be used instead`);
            return false;
        }
        if (!element.pattern ||
            !((0, Common_1.isString)(element.pattern) || (0, Common_1.isArray)(element.pattern))) {
            (0, Debug_1.warnOnce)(`Please provide a valid pattern to type ${element.type} in '${ELEMENTS}' setting`);
            return false;
        }
        if (element.capture && !(0, Common_1.isArray)(element.capture)) {
            (0, Debug_1.warnOnce)(`Invalid capture property of type ${element.type} in '${ELEMENTS}' setting`);
            return false;
        }
        return true;
    }
}
function validateElements(elements) {
    if (!elements || !(0, Common_1.isArray)(elements) || !elements.length) {
        (0, Debug_1.warnOnce)(`Please provide element types using the '${ELEMENTS}' setting`);
        return;
    }
    return elements.filter(isValidElementAssigner);
}
function validateDependencyNodes(dependencyNodes) {
    if (!dependencyNodes) {
        return;
    }
    const defaultNodesNames = Object.keys(DEFAULT_DEPENDENCY_NODES);
    const invalidFormatMessage = [
        `Please provide a valid value in ${DEPENDENCY_NODES} setting.`,
        `The value should be an array of the following strings:`,
        ` "${defaultNodesNames.join('", "')}".`,
    ].join(" ");
    if (!(0, Common_1.isArray)(dependencyNodes)) {
        (0, Debug_1.warnOnce)(invalidFormatMessage);
        return;
    }
    for (const dependencyNode of dependencyNodes) {
        if (!(0, Helpers_1.isDependencyNodeKey)(dependencyNode)) {
            (0, Debug_1.warnOnce)(invalidFormatMessage);
        }
    }
    return dependencyNodes.filter(Helpers_1.isDependencyNodeKey);
}
/**
 * Validates the legacyTemplates setting.
 * @param legacyTemplates The legacyTemplates setting value
 * @returns The validated legacyTemplates value or undefined
 */
function validateLegacyTemplates(
/** The legacyTemplates setting value */
legacyTemplates) {
    if (legacyTemplates === undefined) {
        return;
    }
    if ((0, Common_1.isBoolean)(legacyTemplates)) {
        return legacyTemplates;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES}' setting. The value should be a boolean.`);
}
function isValidDependencyNodeSelector(selector) {
    const isValidObject = (0, Common_1.isObject)(selector) &&
        (0, Common_1.isString)(selector.selector) &&
        (!selector.kind ||
            ((0, Common_1.isString)(selector.kind) &&
                VALID_DEPENDENCY_NODE_KINDS.includes(selector.kind)));
    if (!isValidObject) {
        (0, Debug_1.warnOnce)(`Please provide a valid object in ${ADDITIONAL_DEPENDENCY_NODES} setting. The object should be composed of the following properties: { selector: "<esquery selector>", kind: "value" | "type" }. The invalid object will be ignored.`);
    }
    return isValidObject;
}
function validateAdditionalDependencyNodes(additionalDependencyNodes) {
    if (!additionalDependencyNodes) {
        return;
    }
    const invalidFormatMessage = [
        `Please provide a valid value in ${ADDITIONAL_DEPENDENCY_NODES} setting.`,
        "The value should be an array composed of the following objects:",
        '{ selector: "<esquery selector>", kind: "value" | "type" }.',
    ].join(" ");
    if (!(0, Common_1.isArray)(additionalDependencyNodes)) {
        (0, Debug_1.warnOnce)(invalidFormatMessage);
        return;
    }
    return additionalDependencyNodes.filter(isValidDependencyNodeSelector);
}
function deprecateAlias(aliases) {
    if (aliases) {
        (0, Debug_1.warnOnce)(`Defining aliases in '${ALIAS}' setting is deprecated. Please use 'import/resolver' setting`);
    }
}
function deprecateTypes(types) {
    if (types) {
        (0, Debug_1.warnOnce)(`'${TYPES}' setting is deprecated. Please use '${ELEMENTS}' instead`);
    }
}
function validateIgnore(ignore) {
    if (!ignore) {
        return;
    }
    if ((0, Common_1.isString)(ignore) || ((0, Common_1.isArray)(ignore) && ignore.every(Common_1.isString))) {
        return ignore;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.IGNORE}' setting. The value should be a string or an array of strings.`);
}
function validateInclude(include) {
    if (!include) {
        return;
    }
    if ((0, Common_1.isString)(include) || ((0, Common_1.isArray)(include) && include.every(Common_1.isString))) {
        return include;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE}' setting. The value should be a string or an array of strings.`);
}
function validateRootPath(rootPath) {
    if (!rootPath) {
        return;
    }
    if ((0, Common_1.isString)(rootPath)) {
        return rootPath;
    }
    (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.ROOT_PATH}' setting. The value should be a string.`);
}
function validateFlagAsExternal(flagAsExternal) {
    if (!flagAsExternal) {
        return;
    }
    if (!(0, Common_1.isObject)(flagAsExternal)) {
        (0, Debug_1.warnOnce)(`Please provide a valid value in '${Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL}' setting. The value should be an object.`);
        return;
    }
    const validated = {};
    if (flagAsExternal.unresolvableAlias !== undefined) {
        if ((0, Common_1.isBoolean)(flagAsExternal.unresolvableAlias)) {
            validated.unresolvableAlias = flagAsExternal.unresolvableAlias;
        }
        else {
            (0, Debug_1.warnOnce)(`Please provide a valid boolean for 'unresolvableAlias' in '${Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL}' setting.`);
        }
    }
    if (flagAsExternal.inNodeModules !== undefined) {
        if ((0, Common_1.isBoolean)(flagAsExternal.inNodeModules)) {
            validated.inNodeModules = flagAsExternal.inNodeModules;
        }
        else {
            (0, Debug_1.warnOnce)(`Please provide a valid boolean for 'inNodeModules' in '${Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL}' setting.`);
        }
    }
    if (flagAsExternal.outsideRootPath !== undefined) {
        if ((0, Common_1.isBoolean)(flagAsExternal.outsideRootPath)) {
            validated.outsideRootPath = flagAsExternal.outsideRootPath;
        }
        else {
            (0, Debug_1.warnOnce)(`Please provide a valid boolean for 'outsideRootPath' in '${Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL}' setting.`);
        }
    }
    if (flagAsExternal.customSourcePatterns !== undefined) {
        if ((0, Common_1.isArray)(flagAsExternal.customSourcePatterns) &&
            flagAsExternal.customSourcePatterns.every(Common_1.isString)) {
            validated.customSourcePatterns = flagAsExternal.customSourcePatterns;
        }
        else {
            (0, Debug_1.warnOnce)(`Please provide a valid array of strings for 'customSourcePatterns' in '${Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL}' setting.`);
        }
    }
    return validated;
}
// TODO: Remove settings validation in next major version. It should be done by schema validation only
function validateSettings(settings) {
    deprecateTypes(settings[TYPES]);
    deprecateAlias(settings[ALIAS]);
    return {
        [Settings_types_1.SETTINGS_KEYS_MAP.ELEMENTS]: validateElements(settings[ELEMENTS] || settings[TYPES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.IGNORE]: validateIgnore(settings[Settings_types_1.SETTINGS_KEYS_MAP.IGNORE]),
        [Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE]: validateInclude(settings[Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE]),
        [Settings_types_1.SETTINGS_KEYS_MAP.ROOT_PATH]: validateRootPath(settings[Settings_types_1.SETTINGS_KEYS_MAP.ROOT_PATH]),
        [Settings_types_1.SETTINGS_KEYS_MAP.DEPENDENCY_NODES]: validateDependencyNodes(settings[DEPENDENCY_NODES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES]: validateLegacyTemplates(settings[Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.ADDITIONAL_DEPENDENCY_NODES]: validateAdditionalDependencyNodes(settings[ADDITIONAL_DEPENDENCY_NODES]),
        [Settings_types_1.SETTINGS_KEYS_MAP.CACHE]: settings[Settings_types_1.SETTINGS_KEYS_MAP.CACHE],
        [Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL]: validateFlagAsExternal(settings[Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL]),
    };
}
/**
 * Returns the normalized settings from the ESLint rule context
 * @param context The ESLint rule context
 * @returns The normalized settings
 */
function getSettings(context) {
    const validatedSettings = validateSettings(context.settings);
    const dependencyNodesSetting = (0, Common_1.getArrayOrNull)(validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.DEPENDENCY_NODES]);
    const additionalDependencyNodesSetting = (0, Common_1.getArrayOrNull)(validatedSettings[ADDITIONAL_DEPENDENCY_NODES]);
    const dependencyNodes = 
    // TODO In next major version, make this default to all types of nodes!!!
    (dependencyNodesSetting || [Settings_types_1.DEPENDENCY_NODE_KEYS_MAP.IMPORT])
        .flatMap((dependencyNode) => [
        ...DEFAULT_DEPENDENCY_NODES[dependencyNode],
    ])
        .filter(Boolean);
    const additionalDependencyNodes = additionalDependencyNodesSetting || [];
    const ignoreSetting = validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.IGNORE];
    const ignorePaths = (0, Common_1.isString)(ignoreSetting) ? [ignoreSetting] : ignoreSetting;
    const includeSetting = validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.INCLUDE];
    const includePaths = (0, Common_1.isString)(includeSetting)
        ? [includeSetting]
        : includeSetting;
    const descriptors = (0, Settings_1.transformLegacyTypes)(validatedSettings[ELEMENTS]);
    // NOTE: Filter valid descriptors only to avoid a breaking change for the moment
    const validDescriptors = descriptors.filter(elements_1.isElementDescriptor);
    const invalidDescriptors = descriptors.filter((desc) => !(0, elements_1.isElementDescriptor)(desc));
    if (invalidDescriptors.length > 0) {
        /*
         * TODO: Report invalid descriptors in ESLint context as a warning in a separate rule:
         * context.report({
         * message: `Some element descriptors are invalid and will be ignored: ${JSON.stringify(
         *   invalidDescriptors,
         * )}`,
         * loc: { line: 1, column: 0 },
         * });
         */
        (0, Debug_1.warnOnce)(`Some element descriptors are invalid and will be ignored: ${JSON.stringify(invalidDescriptors)}`);
    }
    const result = {
        elementDescriptors: validDescriptors,
        elementTypeNames: (0, Settings_1.getElementsTypeNames)(validDescriptors),
        ignorePaths,
        includePaths,
        rootPath: (0, Settings_1.getRootPath)(validatedSettings),
        dependencyNodes: [...dependencyNodes, ...additionalDependencyNodes],
        legacyTemplates: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.LEGACY_TEMPLATES] ??
            Settings_types_1.LEGACY_TEMPLATES_DEFAULT,
        cache: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.CACHE] ?? Settings_types_1.CACHE_DEFAULT,
        flagAsExternal: {
            unresolvableAlias: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL]
                ?.unresolvableAlias ?? true,
            inNodeModules: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL]?.inNodeModules ??
                true,
            outsideRootPath: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL]
                ?.outsideRootPath ?? false,
            customSourcePatterns: validatedSettings[Settings_types_1.SETTINGS_KEYS_MAP.FLAG_AS_EXTERNAL]
                ?.customSourcePatterns ?? [],
        },
    };
    return result;
}
